---
// https://codepen.io/miunau/pen/oNVaJoN?editors=1100
// https://codepen.io/miriamsuzanne/pen/yLwRpGQ?editors=1100
import { getImage } from 'astro:assets';
import type { ImageMetadata } from 'astro';
import type { HTMLAttributes } from 'astro/types';

interface BackgroundProperty {
  repeat?: string;
  position?: string;
  size?: string;
}

interface Props extends HTMLAttributes<"div"> {
  tag?: "div" | "section" | "article";
  gradient?: string;
  imagePath?: string;
  gradients?: string[];
  imagePaths?: string[];
  backgroundProperties?: BackgroundProperty[];
  backgroundRepeat?: string;
  backgroundPosition?: string;
  backgroundSize?: string;
  backgroundColor?: string;
  aspectRatio?: string;
  classes?: string;
}

const {
  tag = 'div', // default to section if no tag is provided
  gradient,
  gradients = [],
  imagePath,
  imagePaths = [],
  backgroundProperties = [],
  backgroundRepeat = 'no-repeat',
  backgroundPosition = 'center center',
  backgroundSize = 'cover',
  backgroundColor,
  aspectRatio = '16 / 9',
  classes,
  ...rest
} = Astro.props;

const images = import.meta.glob<{ default: ImageMetadata }>('@images/*.{jpeg,jpg,png,gif,webp,avif}');

let backgrounds = [...gradients];

if (gradient) backgrounds.push(gradient);

async function processImagePath(imagePath: string, index: number) {
  if (!images[imagePath]) throw new Error(`"${imagePath}" does not exist in glob: "@images/*.{jpeg,jpg,png,gif,webp,avif}"`);
  const imageModule = await images[imagePath]();
  const optimizedImage = await getImage({ src: imageModule.default });
  
  // Get the specific background properties if available
  const { repeat = backgroundRepeat, position = backgroundPosition, size = backgroundSize } = backgroundProperties[index] || {};
  
  // Construct imageUrl with specific background properties
  const imageUrl = `url(${optimizedImage.src}) ${repeat} ${position} / ${size}`;
  
  // Push imageUrl into backgrounds array
  backgrounds.push(imageUrl);
}

const imagePathPromises = imagePaths.map((imagePath, index) => processImagePath(imagePath, index));

// Process single imagePath if provided
if (imagePath) {
  await processImagePath(imagePath, -1);
}

await Promise.all(imagePathPromises);

const background = backgrounds.join(', ');

const Tag = tag;
---
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="0">
  <defs>
      <filter id="bwFilter" color-interpolation-filters="sRGB">
          <!-- Convert to grayscale based on luminance -->
          <feColorMatrix type="matrix"
              values="0.2126 0.7152 0.0722 0 0
                      0.2126 0.7152 0.0722 0 0
                      0.2126 0.7152 0.0722 0 0
                      0 0 0 1 0"/>
          <!-- Expand edges slightly to clean up any fringing -->
          <feMorphology operator="dilate" radius="2"/>
          <!-- Apply the threshold to determine if the color should be black or white -->
          <feComponentTransfer>
              <feFuncR type="linear" slope="-255" intercept="128"/>
              <feFuncG type="linear" slope="-255" intercept="128"/>
              <feFuncB type="linear" slope="-255" intercept="128"/>
          </feComponentTransfer>
          <!-- Composite step to clean up the result -->
          <feComposite operator="in" in2="SourceGraphic"/>
      </filter>
  </defs>
</svg>

<style>
  .background { width: 100%; }
</style>

<Tag 
  class:list={['background', 'grid','pile-grid', classes]} 
  style={`
    background: ${background}; 
    background-color: ${backgroundColor}; 
    aspect-ratio: ${aspectRatio};
  `} 
  {...rest}
>
  <!-- content -->
  <slot/>
</Tag>
